# SQLB10   
   
Этот день был посвящён практическому изучению транзакций и уровней изоляции в PostgreSQL. Я на реальных примерах воспроизвела классические аномалии чтения и записи, разобралась, как работает конкурентный доступ к данным, и научилась анализировать ситуации взаимоблокировок. День помогает понять, как СУБД обеспечивает согласованность и целостность данных в условиях параллельных операций.   
**Изученные навыки:**   
- работа с транзакциями в PostgreSQL через несколько параллельных сессий;   
- понимание и демонстрация аномалий: Lost Update, Dirty Read, Non-Repeatable Read, Phantom Read;   
- настройка уровней изоляции (READ COMMITTED, REPEATABLE READ, SERIALIZABLE);   
- анализ поведения транзакций при одновременном доступе;   
- практическое обнаружение и воспроизведение deadlock-ситуаций;   
- исследование механизмов блокировок строк и контроля конкурентности;   
- интерпретация поведения СУБД при конфликтующих изменениях.   
   
   
Модель БД с которой происходила работа   
   
![image](files/image.png)    
Таблица пиццерия   
|     Поле |         Тип |                                                         Описание |
|:---------|:------------|:-----------------------------------------------------------------|
|       id | PRIMARY KEY |                                Уникальный идентификатор пиццерии |
|     name |     VARCHAR |                                                Название пиццерии |
|   rating |     DECIMAL |                             Средний рейтинг пиццерии (от 0 до 5) |

Таблица person   
|     Поле |         Тип |                                                                 Описание |
|:---------|:------------|:-------------------------------------------------------------------------|
|       id | PRIMARY KEY |                                    Уникальный идентификатор пользователя |
|     name |     VARCHAR |                                                         Имя пользователя |
|      age |     INTEGER |                                                     Возраст пользователя |
|   gender |     VARCHAR |                                                         Пол пользователя |
|  address |     VARCHAR |                                                       Адрес пользователя |

Таблица menu   
|         Поле |         Тип |                                                                Описание |
|:-------------|:------------|:------------------------------------------------------------------------|
|           id | PRIMARY KEY |                                   Уникальный идентификатор позиции меню |
| pizzeria\_id | FOREIGN KEY |                                        Ссылка на пиццерию (pizzeria.id) |
|  pizza\_name |     VARCHAR |                                               Название пиццы в пиццерии |
|        price |     DECIMAL |                                                   Цена конкретной пиццы |

Таблица person\_visits   
|         Поле |         Тип |                                                           Описание |
|:-------------|:------------|:-------------------------------------------------------------------|
|           id | PRIMARY KEY |                                 Уникальный идентификатор посещения |
|   person\_id | FOREIGN KEY |                                 Ссылка на пользователя (person.id) |
| pizzeria\_id | FOREIGN KEY |                                   Ссылка на пиццерию (pizzeria.id) |
|  visit\_date |        DATE |                              Дата посещения (например, 2022-01-01) |

Таблица person\_order   
|        Поле |         Тип |                                                     Описание |
|:------------|:------------|:-------------------------------------------------------------|
|          id | PRIMARY KEY |                              Уникальный идентификатор заказа |
|  person\_id | FOREIGN KEY |                           Ссылка на пользователя (person.id) |
|    menu\_id | FOREIGN KEY |                             Ссылка на позицию меню (menu.id) |
| order\_date |        DATE |                           Дата заказа (например, 2022-01-01) |

   
### Задание 00 — Simple transaction   
**Условие**   
Необходимо продемонстрировать, как изменения внутри транзакции становятся видимыми другим пользователям только после фиксации (COMMIT).   
Требуется работать через `psql` в **двух параллельных сеансах**.   
Последовательность действий:   
1. **Session #1**   
    - начать транзакцию;   
    - изменить рейтинг `"Pizza Hut"` на значение `5`;   
    - убедиться, что изменения видны в текущем сеансе.   
2. **Session #2**   
    - выполнить тот же SELECT и убедиться, что обновления *не видны*.   
3. **Session #1**   
    - выполнить `COMMIT`.   
4. **Session #2**   
    - повторно выполнить запрос и убедиться, что теперь изменения доступны.   
   
**Результат: файл `.sql` с командами и скриншоты обоих сеансов.**   
### Задание 01 — Lost Update Anomaly   
**Условие**   
Нужно воспроизвести аномалию «потерянного обновления» (Lost Update) в режиме изоляции **READ COMMITTED**.   
Работа выполняется в двух параллельных `psql`-сеансах.   
Перед началом необходимо убедиться, что уровень изоляции установлен в `read committed`   
(команда `SHOW TRANSACTION ISOLATION LEVEL;`).   
Сценарий:   
1. В обоих сеансах прочитать рейтинг `"Pizza Hut"` внутри транзакции.   
2. **Session #1** должен обновить рейтинг до `4.0`.   
3. **Session #2** должен обновить рейтинг до `3.6` после чтения.   
   
Необходимо показать расхождение между ожидаемым итогом и фактическим результатом — то есть продемонстрировать потерю обновления.   
**Результат: файл `.sql` с командами и скриншоты обоих сеансов.**   
### Задание 02 — Lost Update for Repeatable Read   
**Условие**   
Воспроизвести ту же аномалию потери обновления, но уже при уровне изоляции **REPEATABLE READ**.   
Требуется:   
1. В двух параллельных сеансах открыть транзакции с уровнем `REPEATABLE READ`.   
2. Оба сеанса считывают рейтинг `"Pizza Hut"`.   
3. **Session #1** изменяет рейтинг на `4.0`.   
4. **Session #2** пытается изменить рейтинг на `3.6`.   
   
Нужно зафиксировать, как механизм REPEATABLE READ реагирует на конфликт.   
**Результат: файл `.sql` с командами и скриншоты обоих сеансов.**   
   
### Задание 03 — Non-Repeatable Reads Anomaly   
**Условие**   
Продемонстрировать аномалию «неповторяемого чтения» (Non-Repeatable Read)   
при уровне изоляции **READ COMMITTED**.   
Требуется:   
1. В *Session #1* начать транзакцию и считать рейтинг `"Pizza Hut"` дважды.   
2. Между этими чтениями *Session #2* должен изменить рейтинг на `3.6`.   
3. Показать, что Session #1 получает разные результаты для одного и того же SELECT.   
   

   
**Результат: файл `.sql` с командами и скриншоты обоих сеансов.**   
   
### Задание 04 — Non-Repeatable Reads for Serialization   
**Условие**   
Проверить, возникает ли аномалия неповторяемого чтения   
в режиме **SERIALIZABLE**.   
Процедура:   
1. Оба сеанса начинают транзакции с уровнем SERIALIZABLE.   
2. *Session #1* делает SELECT рейтинга `"Pizza Hut"`.   
3. *Session #2* обновляет рейтинг до `3.0`.   
4. *Session #1* повторяет SELECT.   
   
Нужно показать, что PostgreSQL либо предотвращает аномалию, либо блокирует одну транзакцию.   
**Результат: файл `.sql` с командами и скриншоты обоих сеансов.**   
   
### Задание 05 — Phantom Reads Anomaly   
**Условие**   
Показать аномалию «фантомного чтения»   
на уровне **READ COMMITTED**.   
Сценарий:   
1. В *Session #1* выполнить агрегирующий запрос (например, сумму рейтингов всех пиццерий) внутри транзакции.   
2. До её завершения *Session #2* вставляет новую пиццерию `'Kazan Pizza'` с рейтингом 5 (ID = 10).   
3. Session #1 повторяет свой запрос и получает другой результат.   
   
Необходимо зафиксировать фантомное изменение.   
**Результат: файл `.sql` с командами и скриншоты обоих сеансов.**   
   
### Задание 06 — Phantom Reads for Repeatable Read   
**Условие**   
Повторить эксперимент с фантомными чтениями   
на уровне **REPEATABLE READ**.   
Требуется:   
1. Session #1 считает агрегат по таблице `pizzeria`;   
2. Session #2 вставляет `'Kazan Pizza 2'` с рейтингом 4 (ID = 11);   
3. Session #1 повторяет свой SELECT.   
   
Нужно показать, как PostgreSQL предотвращает фантомы под этим уровнем изоляции.   
**Результат: файл `.sql` с командами и скриншоты обоих сеансов.**   
   
### Задание 07 — Deadlock   
**Условие**   
Требуется вручную смоделировать ситуацию взаимоблокировки (deadlock) в таблице `pizzeria`.   
Для этого нужно:   
- открыть два параллельных `psql`-сеанса,   
- выполнить последовательность UPDATE/SELECT с блокировками строк,   
- организовать перекрёстное ожидание (каждый сеанс ждёт блокировку, удерживаемую другим).   
   
Можно использовать любой уровень изоляции.   
Необходимо предоставить:   
- SQL-файл с командами,   
- скриншоты обоих сеансов,   
- фиксацию ошибки `deadlock detected`.   
   
**Результат: файл `.sql` с командами и скриншоты обоих сеансов.**   
