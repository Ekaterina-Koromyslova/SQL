# TEAM\_02   
Этот день был посвящён работе с архитектурой хранилищ данных и объединению несогласованных источников в единый аналитический слой. Я изучала, как формировать отчёты поверх “грязных” и исторических данных, выбирать корректные версии записей по времени, обрабатывать NULL и аномалии, а также соединять данные из разных микросервисов в единый консистентный результат.   
   
**Изученные навыки**   
- работа с несколькими независимыми источниками данных (микросервисы) как с единым DWH-слоем;   
- обработка аномалий: пропущенные записи, NULL-значения, несогласованные ключи;   
- агрегация финансовых транзакций по пользователям и типам балансов;   
- работа с временными рядами и выбором ближайшего исторического значения;   
- вычисление показателей через формулы (объёмы, пересчёт валют);   
- объединение данных из ODS в DWH для формирования аналитического отчёта;   
- сортировка и построение итоговых отчётных таблиц.   
   
   
### Задание 00 — Classical DWH   
**Условие**   
Работая с моделью хранилища данных (DWH), необходимо построить агрегирующий SQL-запрос, который объединяет сведения из трёх разрозненных источников:   
- **User** (Green Source) — содержит `id`, `name`, `lastname`; допускает `NULL` в имени и фамилии;   
- **Currency** (Red Source) — содержит исторические записи валют: `id`, `name`, `rate\_to\_usd`, `updated`; несколько строк с одинаковым `id`, различаются временем `updated`;   
- **Balance** (Blue Source) — содержит `user\_id`, `money`, `type`, `currency\_id`, `updated`; фактически является транзакционным слоем без истории в исходной системе.   
   
Все три таблицы не связаны внешними ключами, данные могут быть несогласованы, в таблицах могут отсутствовать соответствующие строки.   
Требуется:   
1. Использовать таблицы DWH-уровня ( `User`, `Currency`, `Balance`), загруженные скриптом из Materials.   
2. Написать запрос, который возвращает для каждого пользователя и каждого типа баланса:   
    - `name` — если отсутствует → `"not defined"`;   
    - `lastname` — если отсутствует → `"not defined"`;   
    - `type` — значение поля Balance.type;   
    - `volume` — сумма всех `money` для этого пользователя и типа;   
    - `currency\_name` — если отсутствует → `"not defined"`;   
    - `last\_rate\_to\_usd` — последний курс валюты (самый поздний `updated`) или `1`, если отсутствует;   
    - `total\_volume\_in\_usd` — `volume \* last\_rate\_to\_usd`.   
3. Учитывать, что может не быть ни пользователя, ни валюты, ни их истории.   
4. Отсортировать результат:   
    - по имени — по убыванию,   
    - затем по фамилии,   
    - затем по типу баланса — по возрастанию.   
   
**Разрешено:** ANSI SQL.   
**Структуры, которые нужно использовать:** таблицы User (DWH), Currency (DWH), Balance (DWH), включая их поля `updated`, исторические записи и аномалии данных.   
   
### Задание 01 — Detailed Query   
**Условие**   
Перед выполнением задания необходимо добавить в таблицу `Currency` две дополнительные исторические записи:   
```

insert into currency values (100, 'EUR', 0.85, '2022-01-01 13:29');
insert into currency values (100, 'EUR', 0.79, '2022-01-08 13:29');


```
Требуется написать SQL-запрос, который выводит все** **операции по балансу (Balance), дополненные:   
- именем и фамилией пользователя (NULL → `"not defined"`),   
- названием валюты,   
- значением суммы, пересчитанной в USD по правилу “ближайшего доступного курса”.   
   
Правило выбора курса:   
1. Найти ближайший курс валюты в прошлом относительно времени операции Balance.updated → `t1`.   
2. Если `t1` отсутствует, взять ближайший курс в будущем → `t2`.   
3. Использовать значение курса `t1` или `t2` для конвертации.   
   
Требуется вывести:   
- `name`   
- `lastname`   
- `currency\_name`   
- `currency\_in\_usd` — сумма средств в долларах, рассчитанная по найденному курсу.   
   
Не учитывать транзакции, у которых currency\_id не встречается в таблице Currency.   
Отсортировать результат:   
1. по имени пользователя — по убыванию,   
2. по фамилии — по возрастанию,   
3. по названию валюты — по возрастанию.   
   
**Разрешено:** ANSI SQL.   
**Структуры, с которыми работает запрос:**   
таблицы User, Balance, Currency (со множеством исторических курсов), включая все поля `updated`.   
